/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.ojacobo.algoritmodijkstra.gui;

import javax.swing.JOptionPane;

/**
 *
 * @author Jacobo
 */
public class Principal extends javax.swing.JFrame {

    private static final int MAX_VALUE = Integer.MAX_VALUE - 1000;
    private int nodoOrigen;
    private final int matrizDistancias[][];
    private int padres[];

    /**
     * Creates new form Principal
     */
    public Principal() {
        initComponents();
        nodoOrigen = 0;
        matrizDistancias = new int[][]{
            /**
             * ***** A B D D E F G H
             */
            /* A */{0, 7, 8, 10, -1, -1, -1, -1},
            /* B */ {7, 0, 9, -1, -1, 10, -1, -1},
            /* C */ {8, 9, 0, 3, 7, 6, -1, -1},
            /* D */ {10, -1, 3, 0, 5, -1, -1, 2},
            /* E */ {-1, -1, 7, 5, 0, 2, 2, 4},
            /* F */ {-1, 10, 6, -1, 2, 0, 5, -1},
            /* G */ {-1, -1, -1, -1, 2, 5, 0, 6},
            /* H */ {-1, -1, -1, 2, 4, -1, 6, 0}
        };
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pnlPrincipal = new javax.swing.JPanel();
        cmbSeleccionarNodo = new javax.swing.JComboBox<>();
        btnCalcularDijkstra = new javax.swing.JButton();
        scrollConsola = new javax.swing.JScrollPane();
        txtaConsola = new javax.swing.JTextArea();
        menuBarPrincipal = new javax.swing.JMenuBar();
        Archivo = new javax.swing.JMenu();
        mnuItemSalir = new javax.swing.JMenuItem();
        Operaciones = new javax.swing.JMenu();
        menuItemCalcularDijsktra = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Algoritmo Dijkstra");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        cmbSeleccionarNodo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Nodo 1", "Nodo 2", "Nodo 3", "Nodo 4", "Nodo 5", "Nodo 6", "Nodo 7", "Nodo 8" }));

        btnCalcularDijkstra.setText("Calcular Dijkstra ");
        btnCalcularDijkstra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCalcularDijkstraActionPerformed(evt);
            }
        });

        txtaConsola.setColumns(20);
        txtaConsola.setRows(5);
        scrollConsola.setViewportView(txtaConsola);

        javax.swing.GroupLayout pnlPrincipalLayout = new javax.swing.GroupLayout(pnlPrincipal);
        pnlPrincipal.setLayout(pnlPrincipalLayout);
        pnlPrincipalLayout.setHorizontalGroup(
            pnlPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPrincipalLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(scrollConsola)
                    .addGroup(pnlPrincipalLayout.createSequentialGroup()
                        .addComponent(cmbSeleccionarNodo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCalcularDijkstra)
                        .addGap(0, 284, Short.MAX_VALUE)))
                .addContainerGap())
        );
        pnlPrincipalLayout.setVerticalGroup(
            pnlPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pnlPrincipalLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pnlPrincipalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cmbSeleccionarNodo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(btnCalcularDijkstra))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollConsola, javax.swing.GroupLayout.DEFAULT_SIZE, 211, Short.MAX_VALUE)
                .addContainerGap())
        );

        Archivo.setText("Archivo");

        mnuItemSalir.setText("Salir");
        mnuItemSalir.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                mnuItemSalirActionPerformed(evt);
            }
        });
        Archivo.add(mnuItemSalir);

        menuBarPrincipal.add(Archivo);

        Operaciones.setText("Operaciones");

        menuItemCalcularDijsktra.setText("Calcular Dijsktra");
        menuItemCalcularDijsktra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuItemCalcularDijsktraActionPerformed(evt);
            }
        });
        Operaciones.add(menuItemCalcularDijsktra);

        menuBarPrincipal.add(Operaciones);

        setJMenuBar(menuBarPrincipal);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pnlPrincipal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(pnlPrincipal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void menuItemCalcularDijsktraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuItemCalcularDijsktraActionPerformed
        algoritmoDijsktra();
    }//GEN-LAST:event_menuItemCalcularDijsktraActionPerformed

    private void btnCalcularDijkstraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCalcularDijkstraActionPerformed
        algoritmoDijsktra();
    }//GEN-LAST:event_btnCalcularDijkstraActionPerformed

    private void mnuItemSalirActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_mnuItemSalirActionPerformed
        salir();
    }//GEN-LAST:event_mnuItemSalirActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        salir();
    }//GEN-LAST:event_formWindowClosing

    private void algoritmoDijsktra() {
        txtaConsola.setText("");
        nodoOrigen = cmbSeleccionarNodo.getSelectedIndex();
        imprimirGrafo(matrizDistancias);
        int[] distancias = resolveDijsktra(matrizDistancias, nodoOrigen);
        imprimirDistancias(distancias, nodoOrigen);
        imprimirCaminos(padres, nodoOrigen);
        imprimirMarca();
    }

    public void salir() {
        if (JOptionPane.showConfirmDialog(
                this,
                "¿Desear salir del programa?",
                "Salir del programa",
                JOptionPane.OK_CANCEL_OPTION,
                JOptionPane.INFORMATION_MESSAGE) == JOptionPane.OK_OPTION) {
            System.exit(0);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Principal.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Principal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu Archivo;
    private javax.swing.JMenu Operaciones;
    private javax.swing.JButton btnCalcularDijkstra;
    private javax.swing.JComboBox<String> cmbSeleccionarNodo;
    private javax.swing.JMenuBar menuBarPrincipal;
    private javax.swing.JMenuItem menuItemCalcularDijsktra;
    private javax.swing.JMenuItem mnuItemSalir;
    private javax.swing.JPanel pnlPrincipal;
    private javax.swing.JScrollPane scrollConsola;
    private javax.swing.JTextArea txtaConsola;
    // End of variables declaration//GEN-END:variables

    private int[] resolveDijsktra(int[][] matriz, int nodoOrigen) {
        int nodoActual = nodoOrigen;
        int cantidadNodos = matriz.length;
        int[] distancias = new int[cantidadNodos];
        padres = new int[cantidadNodos];
        boolean[] visitados = new boolean[cantidadNodos];

        for (int idx = 0; idx < cantidadNodos; idx++) {
            distancias[idx] = MAX_VALUE;
            padres[idx] = nodoOrigen;
            visitados[idx] = false;
        }

        // NODO ORIGEN
        distancias[nodoOrigen] = 0;
        visitados[nodoOrigen] = true;
        // BUSCAR Y RELLENAR LAS PRIMERAS DISTANCIAS ADYACENTES AL NODO ORIGEN
        for (int idx = 0; idx < cantidadNodos; idx++) {
            if ((matriz[nodoActual][idx] != 0) && (matriz[nodoActual][idx] != -1)) {
                distancias[idx] = matriz[nodoActual][idx];
            }
        }
        txtaConsola.append("===== PROCESAMIENTO =====\n");
        txtaConsola.append("NODO ORIGEN: " + (nodoOrigen + 1) + "\n");
        while (!visitadosTodos(visitados)) {
            // SELECCIONAR SIGUIENTE MINIMO NO VISITADO
            nodoActual = getMinimoNoVisitado(distancias, visitados);
            // MARCARLO COMO VISITADO
            visitados[nodoActual] = true;
            txtaConsola.append("NODO ACTUAL: " + (nodoActual + 1) + " (" + distancias[nodoActual] + ")\n");
            int[] sucesores = matriz[nodoActual];
            for (int nodo = 0; nodo < sucesores.length; nodo++) {
                // OBTENER NODOS DE ADYACENCIA
                if (isAdyacente(matriz, nodoActual, nodo)) {
                    int sumaDistancias = distancias[nodoActual] + matriz[nodoActual][nodo];
                    if (distancias[nodo] > sumaDistancias) {
                        distancias[nodo] = (distancias[nodoActual] + matriz[nodoActual][nodo]);
                        padres[nodo] = nodoActual;
                    }
                }
            }
        }
        return distancias;
    }

    private int getMinimoNoVisitado(int[] distancias, boolean[] visitados) {
        int numNodos = distancias.length;
        int idxMinimo = -1;
        int minimo = MAX_VALUE;
        for (int idx = 0; idx < numNodos; idx++) {
            if (distancias[idx] < minimo && (visitados[idx] == false)) {
                idxMinimo = idx;
                minimo = distancias[idx];
            }
        }
        return idxMinimo;
    }

    private boolean isAdyacente(int[][] matriz, int nodoActual, int nodo) {
        return (nodo != nodoActual) && (matriz[nodoActual][nodo] != -1);
    }

    private boolean visitadosTodos(boolean[] visitados) {
        int longitud = visitados.length;
        for (int idx = 0; idx < longitud; idx++) {
            if (visitados[idx] == false) {
                return false;
            }
        }
        return true;
    }

    private void imprimirGrafo(int[][] grafo) {
        int longitud = grafo.length;
        txtaConsola.append("===== MATRIZ =====\n");
        txtaConsola.append("    ");
        for (int idx = 0; idx < longitud; idx++) {
            txtaConsola.append("  " + (char)(idx + 65) + " ");
        }
        txtaConsola.append("\n");
        for (int i = 0; i < longitud; i++) {
            txtaConsola.append(" " + (char)(i + 65) + " [");
            for (int j = 0; j < longitud; j++) {
                if (i >= j) {
                    if (grafo[i][j] != -1) {
                        txtaConsola.append("  " + getFormat(grafo[i][j]));
                    } else {
                        txtaConsola.append("  NA");
                    }
                } else {
                    txtaConsola.append("  --");
                }
            }
            txtaConsola.append(" ]\n");
        }
    }

    private void imprimirDistancias(int[] distancias, int nodoOrigen) {
        int longitud = distancias.length;
        txtaConsola.append("===== DISTANCIAS DESDE NODO " + (nodoOrigen + 1) + " =====\n");
        for (int idx = 0; idx < longitud; idx++) {
            txtaConsola.append("DISTANCIA A NODO " + (idx + 1) + ": " + distancias[idx] + "\n");
        }
    }

    private void imprimirCaminos(int[] padres, int nodoOrigen) {
        int longitud = padres.length;
        txtaConsola.append("===== RUTAS DESDE NODO " + (nodoOrigen + 1) + " =====\n");
        for (int idx = 0; idx < longitud; idx++) {
            txtaConsola.append("RUTA NODO " + (idx + 1) + ": " + buscarCamino(padres, nodoOrigen, idx) + "\n");
        }
    }

    private String buscarCamino(int[] padres, int nodoOrigen, int nodoDestino) {
        String camino = "->" + (nodoDestino + 1);
        int nodoAux = nodoDestino;
        while (nodoAux != nodoOrigen) {
            camino = "->" + (padres[nodoAux] + 1) + camino;
            nodoAux = padres[nodoAux];
        }
        return camino;
    }

    private String getFormat(int dato) {
        if (dato > 9 || dato < 0) {
            return "" + dato;
        } else {
            return " " + dato;
        }
    }
    
    private void imprimirMarca() {
        txtaConsola.append("\n\nHECHO POR OMAR JACOBO GARCÍA\n\n");
        txtaConsola.append("SI HUBIERA TENIDO ESTA INSPIRACIÓN EN PRIMER SEMESTRE :(\n");
        txtaConsola.append("LLEGASTE 9 AÑOS TARDE :(\n\n");
        txtaConsola.append("JAJAJAJA XD");
    }
}
